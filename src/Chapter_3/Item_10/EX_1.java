package Chapter_3.Item_10;

/*
equals는 일반 규약을 지켜 재정의 하라
- equals를 재정의 하지 않으면(그냥 두면) 해당 클래스의 인스턴스는 오직 자기 자신과만 같게 될 것임

그래서 아래 작성된 상황 중 하나에 해당하면 재정의 하지 않는 것이 최선이다.
- 각 인스턴스가 본질적으로 고유하다 -> 값을 표현하는게 아닌, 동작하는 개체
	EX) Thread
- 인스턴스의 논리적 동치성을 검사할 일이 없다.
	EX) regex.Pattern은 equals를 재정의해 두 Pattern의 인스턴스가 같은 정규표현식을 나타내는지 검사하는 (이를 논리적 동치성을 검사한다 한다.)
	하지만 설계자가 이를 필요 없다고 느끼면 재정의 할 필요가 없음
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
	EX) 대부분의 Set의 구현체는 AbstractSet이 구현한 equals를 상속받아 그대로 씀 List, Map도 마찬가지
- 클래스가 private 이거나 package-private이고 equals메서드를 호출할 일이 없다.
* */

/*
equals를 재정의 해아 할 때
- 두 객체가 물리적으로 같은가?를 보는게 아니라 논리적 동치성을 확인해야 하는데,
  상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때
  EX) 값 클래스 (Integer, String 처럼 값을 표현하는 클래스)
  
  한줄요약: 객체가 같은지 아니라, 그냥 값이 같은지를 확인하고 싶을 때 쓰면됨 (대신 위에 재정의 하지 않아야 되는 상황 빼고)
  
  그리고 재정의한 equals는 아래 원칙들을 지켜야한다.
  - 반사성
  - 대칭성
  - 추이성
  - 일관성
  - null-아님
  
  그래서 양질의 equals를 구현하려면 아래 단계별로 만드는게 좋다.
  1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
  	=> 자기 자신이면 true 반환, 이는 단순한 성능 최적화용 비교 작업이 복작한 상황일 때를 위해서
  2. instanceof 연사자로 입력이 올바른 타입인지 확인 if ((! o instanceof MyType)) return false;
  	=> 그렇지 않으면 false 반환, 근데 클래스가 인터페이스를 구현한거면 클래스가 아닌 인터페이스를 사용해야 한다.
  3. 입력을 올바른 타입으로 형변환 한다.
  4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하니씩 검사한다.
  5. hashCode도 반드시 재정의한다.
* */
public class EX_1 {
}
