package Chapter_11.Item_84;


/* 프로그램의 동작을 스레드 스케줄러에 기대지 마라

- 여러 스레드가 실행 중이라면 OS의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할지 정한다.
- 운영체제마다 구체적인 스케줄링 정책은 다를 수 있기 때문에, 이 정책에 의존하면 안된다.
- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면, 다른 플랫폼에 이식하기 어렵다.

좋은 프로그램을 만드는 Tip
- 실행 가능한 스레드의 평균 수를 프로세서 수보다 지나치게 많이 가져가지 않도록 할 것
- 실행 준비가 된 스레드들은 맡은 작업을 완료할 때 까지 계속 실행되게 하자
- > 이렇게 하면 스케줄링 정책이 다르더라도 크게 지장받지 않는다.

실행 가능한 스레드 수를 적게 유지하는 Tip
- 스레드가 작업을 완료한 후에는 다음 작업이 생길 때 까지 대기하도록 하는 것
- 스레드는 당장 처리해야할 작업이 없다면 실행되서는 안된다.
EX) 실행자 프레임워크로 스레드 풀 크기를 적절히 설정하고, 작업은 짧게 유지한다. (단, 너무 짧으면 작업 분배 부담으로 성능 저하가 올 수 있다.)

스레드와 바쁜 대기 상태
바쁜대기 상태 = 임계 영역에서 작업중인 스레드 B를 기다리는 스레드 A가 있을 때, 스레드 A가 임계 영역에 들어갈 수 있을지 계속 검사하는 상태
- 스레드는 바쁜 대기 상태가 되면 안된다. 절대로
- 바쁜 대기는 스레드 스케줄러 변덕에 취약하며, 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다.
* */

/* 바쁜 대기 상태의 CountDownLatch 예시
- 하나 이상의 스레드가 필요도 없이 실행 가능한 상태인 시스템은 아래같은 모습
- 특정 스레드가 다른 스레드들과 비교해 CPU 시간을 충분히 얻지 못해 간신히 돌아가는 프로그램을 보더라도 Thread.yield를 쓸 생각은 자제하라
	- 증상은 호전될 수 있지만, 이식성은 그렇지 않다.
	- 처음 JVM에서는 성능을 높여준 yield가 두번째 JVM에서는 아무 효과도 없을 수도, 심지어 성능 저하가 일어 날수도
	- Thread.yield는 테스트할 수단이 없다.
- 애플리케이션 구조를 바꿔 동시에 실행 가능한 스레드 수가 적어지도록 조치하자
- 스레드의 우선순위를 조정하는 것도 위험이 따른다.
	- 스레드 우선수누이는 자바에서 이식성이 가장 나쁜 특성을 가진다.
* */
class SlowCountDownLatch {
	private int count;
	
	public SlowCountDownLatch(int count) {
		if (count < 0) {
			throw new IllegalArgumentException(count + "< 0");
		}
		this.count = count;
	}
	
	public void await() {
		while (true) {
			synchronized (this) {
				if (count == 0) return;
			}
		}
	}
	
	public synchronized void countDown() {
		if (count != 0) {
			count--;
		}
	}
}




















public class Item_84 {
}
